---
title: Resultater fra hønsefugltakseringene
author: "NINA / HiNN"
date: 23\. august 2021
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \makeatletter
- \let\ps@plain\ps@fancy
- \makeatother
- \fancyhf{}
- \fancyhead[CO,CE]{\includegraphics{logosmall.png}}
- \fancyfoot[CO,CE]{Hønsefuglportalen 2021}
- \fancyfoot[LE,RO]{\thepage}
- \setlength\headheight{41.1pt}
output: pdf_document
---

### Kommentarer      
Vi vil påpeke at det er rettighetshaverne som er ansvarlige for at linjene er lagt ut slik at de er representative for områdene de er ment å dekke. Dersom linjene ligger i habitater hvor det generelt er høyere tettheter enn i resten av området vil tettheten overestimeres. I tilfeller hvor linjefordelingen er dårlig balansert mellom områder (mange linjer i noen små områder, få linjer i store områder) vil dette kunne påvirke resultatene. I disse tilfellene bør man betrakte estimatene som en indeks og ikke som et presist mål på tettheten i forvaltningsområdet.   

På grunn av korte tidsfrister er det også tatt utgangspunkt i at lokalkontakter og regionansvarlige har stått for kvalitetssikringen av dataene. 

### Metoder
For å forenkle og standardisere analysene har vi valgt å analysere alle data med en såkalt «Half Normal» (HN) oppdagbarhetsfunksjon. Dette gjør at det blir enklere å sammenlikne data mellom områder med lite og mere data, og denne funksjonen er også langt mer stabil enn andre mer parameterrike funksjoner (som f.eks Hazard) og funksjoner med ulike serie-ekspansjoner. «Half Normal» er den enkleste oppdagbarhetsfunksjonen, og man estimerer kun en parameter (en såkalt «scale»-parameter) som er et uttrykk for hvor vid fordelingen er. Selv i tilfeller med relativt mye data vil ofte de andre funksjonene være noe ustabile i den grad at estimatene endrer seg raskt selv med små endringer i datasettet. Vi har likevel vurdert andre funksjoner, og vil rapportere resultater også fra disse dersom de gir helt andre resultater. 

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### 1. DEFINE WORK SPACE:
      #setwd("~/12169400 - Hønsefuglportalen 2 (EBN)/ANALYSER OG TAKSERING/TAKSERINGSANALYSER/Analyser 2021/Statskog/Helgeland 1")
      library(Distance)
      library(knitr)
      library(HFP)
      library(pander)
      library(dplyr)
      library(RODBC)
      library(ggplot2)
      library(ggpubr)
      library(lubridate)
      library(xml2)

```

```{r DATA IMPORT NINA, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}

### 2. LOAD AND FORMAT DATA SET

      conn <- odbcDriverConnect("driver={SQL Server}; server=ninsql07; database=Honsefugl; trusted_connection=true")
      Kommune <- sqlFetch(conn, "FYLKEKOMMUNE")
      Taks <- sqlQuery(conn, paste("SELECT TakseringID, LengdeTaksert, FK_LinjeID, Temperatur, SettSMagnager, Aar, FK_HundeforholdID FROM Taksering"))
      TaksLin <- sqlQuery(conn, paste("SELECT LinjeID, FK_OmradeID, Linjenavn, Aktiv, STAsText FROM Takseringslinje"))
      #AktLin = sqlQuery(conn, paste("SELECT LinjeID, FK_OmradeID, STAsText, Linjenavn, Aktiv FROM Takseringslinje"))
      TaksOmr <- sqlQuery(conn, paste("SELECT OmradeID, FK_Fylkekomnr, OmradeNavn, FK_RapporteringsnivaaID FROM Takseringsomrade"))
      Region <- sqlQuery(conn, paste("SELECT ID, Navn, FK_RegionID FROM Rapporteringsnivaa"))
      Obs <- sqlQuery(conn, paste("SELECT ObservasjonId, Aar, LinjeAvstand, FK_TakseringID, AntallHann, AntallHunn, AntallKylling, AntallUkjent, FK_ArtId FROM Observasjon"))
      close(conn)
      
      #Merge data
      df <- merge(Taks, TaksLin, by.x = "FK_LinjeID", by.y = "LinjeID", all.x = T, all.y = F)
      df <- merge(df, TaksOmr, by.x = "FK_OmradeID", by.y = "OmradeID", all.x = T, all.y = F)
      df <- merge(df, Kommune, by.x = "FK_Fylkekomnr", by.y = "Fylkekomnr", all.x = T, all.y = F)
      df <- merge(df, Region, by.x = "FK_RapporteringsnivaaID", by.y = "ID", all.x = T, all.y = F)
      df$Rapporteringsniva <- df$Navn
      df$RegionID <- df$FK_RegionID
      df$Fylkesnavn <- trimws(df$Fylkesnavn)
      df$Kommunenavn <- trimws(df$Kommunenavn)
      df$Rapporteringsniva <- trimws(df$Rapporteringsniva)
      df$OmradeNavn <- trimws(df$OmradeNavn)
      Obs$TakseringID <- Obs$FK_TakseringID
      
### 3. SUBSET DATA
      
      # Fix problems with æ, ø and å letters
      ReportLevel = df$Rapporteringsniva
      ReportLevel = gsub("Ã¸", "ø", x = ReportLevel)
      ReportLevel = gsub("Ã…", "Å", x = ReportLevel)
      ReportLevel = gsub("Ã˜", "Ø", x = ReportLevel)
      ReportLevel = gsub("Ã¥", "å", x = ReportLevel)
      ReportLevel = gsub("Ã¦", "æ", x = ReportLevel)
      df$Rapporteringsniva = ReportLevel
      
      # Report level variable that will be used for sub-setting data and plotting
      ReportLevelOut = sample(unique(ReportLevel), size = 1, replace = FALSE) # DELETE AFTER TESTING
      #ReportLevelOut = "Bjoreidalen - syd/nord" 
      AarInput = 2021
      
      d_1 <- df %>% filter(Rapporteringsniva==ReportLevelOut, Aar==AarInput)
      
      j = 0
      while(dim(d_1)[1] == 0){
        j = j + 1
        d_1 = df %>% filter(Rapporteringsniva == ReportLevelOut, Aar == AarInput - j)
      }
      
      d_1 <- left_join(d_1, Obs, by = "TakseringID")

      #Add ArtNavn (also needed for scripts in the HFP-package)
      d_1 <- transform(d_1, Artnavn=ifelse(FK_ArtId==1, "Lirype", 
                                       ifelse(FK_ArtId==2, "Fjellrype",
                                              ifelse(FK_ArtId==3, "Storfugl",
                                                     ifelse(FK_ArtId==4, "Orrfugl", "Jerpe")))))
      
      d_1 <- d_1 %>% mutate(cs = AntallHann + AntallHunn + AntallKylling + AntallUkjent, År = Aar.x, Year = Aar.x, LinjeID = FK_LinjeID)
      d <- d_1 #%>% filter(Rapporteringsniva!="Pasvik")

### 4. DEFINE SPECIES - SINGLE SPECIES ANALYSIS;
###     
      Art1 <- "Lirype"
      Art2 <- ifelse(Art1=="Lirype", "lirype", "skogsfugl")
      
# ### 4. DEFINE SPECIES - SINGLE SPECIES ANALYSIS;
# ###     
#       Art1 <- "Lirype"
#       Art2 <- ifelse(Art1=="Lirype", "lirype", "skogsfugl")
#       
### 4B: DEFINE SPECIES - COMBINED ANALYSIS OF BLACK GROUSE AND CAPERCAILLIE:
### when analysing "skogsfugl", apply this section. 
      #Art1 <- "Skogsfugl"
      #d <- transform(d, Artnavn==ifelse(Artnavn=="Storfugl", "Skogsfugl", 
      #ifelse(Artnavn=="Orrfugl", "Skogsfugl", Artnavn)))
      
      message(ReportLevelOut) # USED FOR TESTING TO SEE WHICH AREA CREATES ERRORS
      
```

```{r DATA IMPORT EVENSTAD, eval = FALSE, echo = FALSE, message = FALSE}

# Function to read XML files into R
readExcelXML <- function(filename, sheet) {
        require(xml2)
        doc <- read_xml(filename)
        ns <- xml_ns(doc)
        rows <- xml_find_all(doc, paste0(".//ss:Worksheet[@ss:Name='", sheet, "']/ss:Table/ss:Row"), ns = ns)
        values <- lapply(rows, . %>% xml_find_all(".//ss:Cell/ss:Data", ns = ns) %>% xml_text %>% unlist)
        columnNames <- values[[1]]
        
        dat <- do.call(rbind.data.frame, c(values[-1], stringsAsFactors = FALSE))
        names(dat) <- columnNames
        
        # tilegn kolonnetyper --> NB! Gjort manuelt (funker ikke automatisk) - må ev. oppdateres hvis endringer i eksport-format
        #types <- rows[[2]] %>% xml_find_all(".//ss:Cell/ss:Data") %>% xml_attrs %>% unlist %>% setNames(nm = names(dat))
        types <- c("Number","String","Number","String","Number","String","Number","String","Number","String","Number","String",
          "String","Number","String","Number","String","String","String","Number","Number","Number","String","Number",
          "String","String","Number","Number","Number","Number","Number","String","String","String","String","String")
        names(types) <- names(dat)
        funcs <- c("Number" = as.integer, "String" = as.character, "DateTime" = . %>% as.POSIXct(format = "%Y-%m-%dT%H:%M:%S."))

        for (iCol in names(dat)) {
          dat[[iCol]] <- funcs[[types[iCol]]](dat[[iCol]])
        }
        
        dat
      }


df = readExcelXML("C:/Users/markus.israelsen/OneDrive - NINA/GitHub/HonsefuglReport/Honsefugl-Report/XML/Rapport_2_21_0_0_Helgeland_1_2013-2021.xml", "Sheet1")
df = df %>% mutate(Aar = year(dmy(substr(paste(df$Dato), start = 1, stop = 10)))) # Add year to all observations
df = df %>% mutate(FK_ArtId = ifelse(Artnavn == "Lirype", 1, 
                                     ifelse(Artnavn == "Fjellrype", 2, 
                                            ifelse(Artnavn == "Storfugl", 3, 
                                                   ifelse(Artnavn == "Orrfugl", 4, 
                                                          ifelse(Artnavn == "Jerpe", 5, Artnavn))))))
df = df %>% mutate(Rapporteringsniva = Navn)
df = df %>% mutate(SettSmagnager = ifelse(SettSmagnager == "True", 1, ifelse(SettSmagnager == "False", 0, SettSmagnager))) 
df$SettSmagnager = as.integer(df$SettSmagnager)

# Fix problems with æ, ø and å letters (if present)
      ReportLevel = df$Rapporteringsniva
      ReportLevel = gsub("Ã¸", "ø", x = ReportLevel)
      ReportLevel = gsub("Ã…", "Å", x = ReportLevel)
      ReportLevel = gsub("Ã˜", "Ø", x = ReportLevel)
      ReportLevel = gsub("Ã¥", "å", x = ReportLevel)
      ReportLevel = gsub("Ã¦", "æ", x = ReportLevel)
      df$Rapporteringsniva = ReportLevel
      
      # Report level variable that will be used for sub-setting data and plotting
      ReportLevelOut = "Helgeland 1" 
      
      d_1 = df %>% filter(Navn==ReportLevelOut, Aar==2021)
      
      d_1 = d_1 %>% mutate(cs = AntallHann + AntallHunn + AntallKylling + AntallUkjent, År = Aar, Year = Aar)
      d = d_1 #%>% filter(Rapporteringsniva!="Pasvik")

### 4. DEFINE SPECIES - SINGLE SPECIES ANALYSIS;
###     
      Art1 <- "Lirype"
      Art2 <- ifelse(Art1=="Lirype", "lirype", "skogsfugl")
      
    
      #Obs = df %>% dplyr::select(ObservasjonId, Aar, LinjeAvstand, TakseringID, AntallHann, AntallHunn, AntallKylling, AntallUkjent, FK_ArtId)

```

```{r 1 - NINA & EVENSTAD, echo=FALSE, message=FALSE}
### 5. SET DISTANCE AND CS ETC
      d <- transform(d, LinjeAvstand=ifelse(Artnavn==Art1, LinjeAvstand, NA))
      d <- transform(d, AntallHann=ifelse(Artnavn==Art1, AntallHann, NA))
      d <- transform(d, AntallHunn=ifelse(Artnavn==Art1, AntallHunn, NA))
      d <- transform(d, AntallKylling=ifelse(Artnavn==Art1, AntallKylling, NA))
      d <- transform(d, AntallUkjent=ifelse(Artnavn==Art1, AntallUkjent, NA))
      d <- transform(d, cs=ifelse(Artnavn==Art1, cs, NA))

# ### 6. DEFINE NUMBER OF JUVENILES AND ADULTS; 

      d <- transform(d, ad_t=AntallHann+AntallHunn)
      #d <- transform(d, cs=ad_t+AntallUkjent+AntallKylling)
      d <- transform(d, ad=ifelse(cs<1.99, ad_t, 2))
      d <- transform(d, juv=ifelse(cs<1.99, 0, cs-ad))

```

```{r 2 - NINA & EVENSTAD, echo=FALSE, message=FALSE}

#### 7. DEFINE IF THERE ARE ANY STRATA IN YOUR DATA;

    strat <- "No"   # "År", "OmradeNavn", eller "No"

### 8. DEFINING DATA STRUCTURE FOR ANALYSIS; 

    Data_table <- dat_tab(strat)
    Data_table_ad <- dat_tab_ad(strat=strat)
    Obs_table <- obs_tab(strat)
    Sample_table <- samp_tab(strat)
    Region_table <- reg_tab(strat)
      
```

```{r 3 - NINA & EVENSTAD, echo=FALSE, message=FALSE}
    trunk <- "11%"
    ### 10: THE BASIC DISTANCE SAMPLING MODEL: ESTIMATING THE DETECTION FUNCTION
     ds.model1 <- ds(Data_table, region_table=Region_table, sample_table=Sample_table, 
            obs_table=Obs_table, 
            adjustment=NULL, transect="line", truncation=trunk, 
            formula= ~1, key="hn")
    
     ### 13: ESTIMATING ADULT DENSITY
    ds.model2 <- ds(Data_table_ad, region_table=Region_table, sample_table=Sample_table, 
            obs_table=Obs_table, 
            adjustment=NULL, transect="line", truncation=trunk, 
            formula= ~1, key="hn")

    ### 14A: ESTIMATING BROOD SIZE POOLED
      Rekrutt_all <- rec(strat="No")
     
```

### Oversikt over datagrunnlaget

**Tabell 1**. Deskriptiv statistikk for `r paste(d$Navn[1])` i `r paste(d$Year[1])`.  
```{r 4 - NINA & EVENSTAD, echo=FALSE, results='asis'}

     strat <- "OmradeNavn"   # "År", "OmradeNavn", eller "No"

     Data_table <- dat_tab(strat)
     Data_table_ad <- dat_tab_ad(strat=strat)
     Obs_table <- obs_tab(strat)
     Sample_table <- samp_tab(strat)
     Region_table <- reg_tab(strat) 
      
     panderOptions("table.split.table", 120)
     panderOptions("table.alignment.default", "left")
     pander(Desc_omr(), missing="")
     
```

```{r 5 - NINA & EVENSTAD, echo = FALSE, message = FALSE}

allSpecies = d

# Added some more species to show how it would look (CODE MUST BE REMOVED LATER) 
#allSpecies$Artnavn[1:2] = "Fjellrype"
#allSpecies$Artnavn[10:13] = "Jerpe"
#allSpecies$Artnavn[30:33] = "Orrfugl"
#allSpecies$Artnavn[34:36] = "Storfugl"
#allSpecies$FK_ArtId[1:2] = 2
#allSpecies$FK_ArtId[10:13] = 5
#allSpecies$FK_ArtId[30:33] = 4
#allSpecies$FK_ArtId[34:36] = 3

allSpecies = allSpecies %>% mutate(Counter = ifelse(FK_ArtId >= 0, 1, NA))
allSpeciesTable = allSpecies %>% group_by(Artnavn) %>% summarise(NObs = sum(Counter))
allSpeciesTable = na.omit(allSpeciesTable)
noOfSpecies = length(allSpeciesTable$Artnavn)
willowPtar = data.frame(allSpeciesTable[which(allSpeciesTable$Artnavn == "Lirype"), ])
otherSpecies = data.frame(allSpeciesTable[which(allSpeciesTable$Artnavn != "Lirype"), ])

```

Merk at estimater kun er gjort for `r paste(Art2)` (`r willowPtar$NObs` observasjoner, som over). `r paste(ifelse(noOfSpecies == 5, paste("Det ble også registrert ", otherSpecies$Artnavn[1], " (",otherSpecies$NObs[1]," obs.), ", otherSpecies$Artnavn[2], " (", otherSpecies$NObs[2], " obs.), ", otherSpecies$Artnavn[3], " (", otherSpecies$NObs[3], " obs.)", " og ", otherSpecies$Artnavn[4], " (", otherSpecies$NObs[4], " obs.).", sep =""), 
             ifelse(noOfSpecies == 4, paste("Det ble også observert ", otherSpecies$Artnavn[1], " (",otherSpecies$NObs[1]," obs.), ", otherSpecies$Artnavn[2], " (", otherSpecies$NObs[2], " obs.)", " og ", otherSpecies$Artnavn[3], " (", otherSpecies$NObs[3], " obs.).", sep =""), 
                    ifelse(noOfSpecies == 3, paste("Det ble også observert ", otherSpecies$Artnavn[1], " (",otherSpecies$NObs[1]," obs.)", " og ", otherSpecies$Artnavn[2], " (", otherSpecies$NObs[2], " obs.).", sep =""), 
                           ifelse(noOfSpecies == 2, paste("Det ble også observert ", otherSpecies$Artnavn[1], " (",otherSpecies$NObs[1]," obs.).", sep =""), 
                                  ifelse(noOfSpecies == 1, "Øvrige arter ble ikke observert."))))))`

\pagebreak

## Resultater

**Tabell 2**. Resultater for `r paste(Art2)` i `r paste(d$Navn[1])` i `r paste(d$Year[1])`. Kyllingproduksjon rapporteres som antall kyllinger per par (per høne for skogsfugl). Nedre CL og Øvre CL representerer henholdsvis øvre og nedre konfidensintervall (med 95% sikkerhet), og CV representerer variasjonskoeffisienten (spredningen i resultatene).
```{r 6 - NINA & EVENSTAD, echo=FALSE, results='asis'}

     panderOptions("table.split.table", 120)
     panderOptions("table.alignment.default", "left")
     pander(samle_res())
      
```

\ \newline
```{r 7 - NINA & EVENSTAD, echo = FALSE, message = FALSE}
# DATA MANAGEMENT FOR TIME SERIES FIGURE
### DATA FOR TIME SERIES FIGURE

  timeSeries = df %>% filter(Aar >= 2013, Rapporteringsniva == ReportLevelOut)

```

```{r NINA, eval = TRUE, echo = FALSE, message = FALSE}
  timeSeries = left_join(timeSeries, Obs, by = "TakseringID")
  timeSeries = transform(timeSeries, Artnavn = ifelse(FK_ArtId==1, "Lirype",
                                                     ifelse(FK_ArtId==2, "Fjellrype",
                                                            ifelse(FK_ArtId==3, "Storfugl",
                                                                   ifelse(FK_ArtId==4, "Orrfugl", "Jerpe")))), Aar = Aar.x, LinjeID = FK_LinjeID)
  
```

```{r 8 - NINA OG EVENSTAD, echo = FALSE, message = FALSE}

  timeSeries = timeSeries %>% mutate(cs = AntallHann + AntallHunn + AntallKylling + AntallUkjent, År = Aar, Year = Aar)
  
  ### SET DISTANCE AND CS ETC
  timeSeries <- transform(timeSeries, LinjeAvstand=ifelse(Artnavn==Art1, LinjeAvstand, NA))
  timeSeries <- transform(timeSeries, AntallHann=ifelse(Artnavn==Art1, AntallHann, NA))
  timeSeries <- transform(timeSeries, AntallHunn=ifelse(Artnavn==Art1, AntallHunn, NA))
  timeSeries <- transform(timeSeries, AntallKylling=ifelse(Artnavn==Art1, AntallKylling, NA))
  timeSeries <- transform(timeSeries, AntallUkjent=ifelse(Artnavn==Art1, AntallUkjent, NA))
  timeSeries <- transform(timeSeries, cs=ifelse(Artnavn==Art1, cs, NA))
  
  ### DEFINE NUMBER OF JUVENILES AND ADULTS; 
  timeSeries <- transform(timeSeries, ad_t=AntallHann+AntallHunn)
  timeSeries <- transform(timeSeries, cs=ad_t+AntallUkjent+AntallKylling)      
  timeSeries <- transform(timeSeries, ad=ifelse(cs<1.99, ad_t, 2)) 
  timeSeries <- transform(timeSeries, juv=ifelse(cs<1.99, 0, cs-ad)) 
  
  #### DEFINE IF THERE ARE ANY STRATA IN YOUR DATA;
  strat <- "No"   # "Year", "OmradeNavn", eller "No"
  
  # Create and empty table to save all the estimates in
  years = c(2013:max(unique(d$Year)))
  timeSeriesDF = matrix(data = c(rep(NA, 15)*length(years)), nrow = 3*length(years), ncol = 5, dimnames = list(c(), c("Estimat", "Nedre CL", "Øvre CL", "År", "Faktor")))
  timeSeriesDF = as.data.frame(timeSeriesDF)
  timeSeriesDF$Year = c(sort(rep(years, 3)))
  timeSeriesDF$Faktor = c(rep(c(1, 2, 3), length(years))) # 1 = total tetthet, 2 = tetthet av voksen fugl, 3 = kyllingproduksjon
  
  # For loop that runs through all the years and calculates the density estimates
  estimat = rep(NA, (length(years)*3))
  nedreCL = rep(NA, (length(years)*3))
  ovreCL = rep(NA, (length(years)*3))
  #censusStart = 0
  #gapYear = c()
  for(i in 1:length(years)){

    print(paste(i, "Start", sep = " "))
    d = timeSeries # Set the timeseries dataset equal to "d" so that the functions below work as intended
    d = d %>% filter(Year == years[i])
    
    # If monitoring had not started (num of rows in d == 0), increase "i" and redefine "d"
    while(dim(d)[1] < 20 | length(unique(d$LinjeAvstand)) < 2){ #| dim(d)[1] == 0){
      
      
      #if(dim(d)[1] == 0){
      #  i = i + 1
      #  d = timeSeries %>% filter(Year == years[i])
       # censusStart = censusStart + 1 
      #}
      
      if(i == 1){
        estimat[i:(i*3)] = rep(100000, 3)
        nedreCL[i:(i*3)] = rep(100000, 3)
        ovreCL[i:(i*3)] = rep(100000, 3)
      }
      if(i != 1){
        estimat[((i*2)+(i-2)):(i*3)] = rep(100000, 3)
        nedreCL[((i*2)+(i-2)):(i*3)] = rep(100000, 3)
        ovreCL[((i*2)+(i-2)):(i*3)] = rep(100000, 3)
        }
      
      
      #if(dim(d)[1] < 20){
        #gapYear = append(gapYear, i)
        i = i + 1
        d = timeSeries %>% filter(Year == years[i])
      #}
      
      if(i >= length(years)){
        #gapYear = append(gapYear, i)
        #censusStart = censusStart + 1
        d = d[1, ]
        d[1, ] = NA
        break
      } 
    }
    
    if(dim(d)[1] == 1 & all(is.na(d))){
      break
    }
    
    # Check Data_table - Number of obs and number of distance == 0
    checkDT = dat_tab(strat, dataset = d) %>% count(distance)
    sumN = sum(checkDT$n)
    propDistZero = checkDT[which(checkDT$distance == 0), 2] / sumN
    if(length(propDistZero) == 0){
      propDistZero = 0
    }
    
    if(propDistZero > 0.40 ){#| sumN < 20){ # If TRUE this years estimates have to be set as NA
      #gapYear = append(gapYear, i)
      if(i == 1){
        estimat[i:(i*3)] = rep(100000, 3)
        nedreCL[i:(i*3)] = rep(100000, 3)
        ovreCL[i:(i*3)] = rep(100000, 3)
      }
      if(i != 1){
        estimat[((i*2)+(i-2)):(i*3)] = rep(100000, 3)
        nedreCL[((i*2)+(i-2)):(i*3)] = rep(100000, 3)
        ovreCL[((i*2)+(i-2)):(i*3)] = rep(100000, 3)
        }
      i = i + 1
      d = timeSeries %>% filter(Year == years[i])
      #estimat = append(estimat, rep(NA, 3))
      #nedreCL = append(nedreCL, rep(NA, 3))
      #ovreCL = append(ovreCL, rep(NA, 3))
    }
    
    else{
      ### 8. DEFINING DATA STRUCTURE FOR ANALYSIS; 
    
    Data_table <- dat_tab(strat, dataset = d)
    Data_table_ad <- dat_tab_ad(strat=strat, dataset = d)
    Obs_table <- obs_tab(strat)
    Sample_table <- samp_tab(strat)
    Region_table <- reg_tab(strat)
    
    
    
    trunk <- "11%"
    ### 10: THE BASIC DISTANCE SAMPLING MODEL: ESTIMATING THE DETECTION FUNCTION
        ds.model1 <- ds(Data_table, region_table=Region_table, sample_table=Sample_table, 
              obs_table=Obs_table, 
              adjustment=NULL, transect="line", truncation=trunk, 
              formula= ~1, key="hn")
        
    ### 13: ESTIMATING ADULT DENSITY
        ds.model2 <- ds(Data_table_ad, region_table=Region_table, sample_table=Sample_table, 
              obs_table=Obs_table, 
              adjustment=NULL, transect="line", truncation=trunk, 
              formula= ~1, key="hn")
    
    ### 14A: ESTIMATING BROOD SIZE POOLED
        Rekrutt_all <- rec(strat="No")
    
    # Append the estimate and CI to the respective vectors
    if(i == 1){
      estimat[i:(i*3)] = as.numeric(samle_res()$Estimat)
      nedreCL[i:(i*3)] = as.numeric(samle_res()$`Nedre CL`)
      ovreCL[i:(i*3)] = as.numeric(samle_res()$`Øvre CL`)
    }
    if(i != 1){
      estimat[((i*2)+(i-2)):(i*3)] = as.numeric(samle_res()$Estimat)
      nedreCL[((i*2)+(i-2)):(i*3)] = as.numeric(samle_res()$`Nedre CL`)
      ovreCL[((i*2)+(i-2)):(i*3)] = as.numeric(samle_res()$`Øvre CL`)
      }
    #estimat = append(estimat, as.numeric(samle_res()$Estimat))
    #nedreCL = append(nedreCL, as.numeric(samle_res()$`Nedre CL`))
    #ovreCL = append(ovreCL, as.numeric(samle_res()$`Øvre CL`))
    }
    if(i == length(years)){
      break
    }
    print(paste(i, "End", sep = " "))
  }
  
  # If some of the first years are missing (monitoring had not started yet) the rows are set as NA
  #if(censusStart > 0){
    #for(i in 1:max(censusStart)){
   #   NAlist = rep(NA, length(seq(1:(censusStart*3))))
    #  estimat = append(NAlist, estimat)
     # nedreCL = append(NAlist, nedreCL)
      #ovreCL = append(NAlist, ovreCL)
      #estimat[seq(1:(censusStart*3))] = NA
      #nedreCL[seq(1:(censusStart*3))] = NA
      #ovreCL[seq(1:(censusStart*3))] = NA
    #}
  #}

# Add the estimate and CI to the time series dataset
  timeSeriesDF$Estimat = estimat
  timeSeriesDF$`Nedre CL` = nedreCL
  timeSeriesDF$`Øvre CL` = ovreCL
  timeSeriesDF = timeSeriesDF %>% mutate(Estimat = ifelse(Estimat == 100000, NA, Estimat), `Nedre CL` = ifelse(`Nedre CL`==100000, NA, `Nedre CL`), `Øvre CL`=ifelse(`Øvre CL`==100000, NA, `Øvre CL`))
  # if(!is.null(gapYear)){
  #   #gapNA = rep(NA, 3*length(gapYear))
  #   for(i in gapYear){
  #    timeSeriesDF = timeSeriesDF %>% mutate(Estimat = ifelse(Year == years[i], NA, Estimat), `Nedre CL` = ifelse(Year == years[i], NA, `Nedre CL`), `Øvre CL` = ifelse(Year == years[i], NA, `Øvre CL`)) 
  #   }
  # }
  
  # Subset data for the various categories (total, ad, chick and rodents)
  timeSeriesDF$Year = as.character.Date(timeSeriesDF$Year)
  timeSeriesTot = timeSeriesDF %>% filter(Faktor == 1)
  timeSeriesAd = timeSeriesDF %>% filter(Faktor == 2)
  timeSeriesChick = timeSeriesDF %>% filter(Faktor == 3)
  
  # Function for setting y-axis values as integers
  integer_breaks = function(n = 5, ...) {
    fxn = function(x) {
      breaks = floor(pretty(x, n, ...))
      names(breaks) = attr(breaks, "labels")
      breaks
    }
    return(fxn)
  }
  
```

```{r RODENTS TIMESERIES NINA, eval = TRUE, echo = FALSE}

# Calculate the number of rodents observed
  timeSeries$Year = as.character.Date(timeSeries$Year)
  timeSeriesRodents = timeSeries %>% filter(Aktiv == 1) # Subset data only on lines that are active
  timeSeriesRodents = timeSeriesRodents %>% mutate(NumLines = 1) 
  timeSeriesRodents = timeSeriesRodents %>% group_by(Year) %>% summarise(SeeRodPercent = (sum(SettSMagnager)/sum(NumLines))*100)
  
```

```{r RODENTS TIMESERIES EVENSTAD, eval = FALSE, echo = FALSE}  

  # Calculate the number of rodents observed
  timeSeries$Year = as.character.Date(timeSeries$Year)
  timeSeriesRodents = df %>% filter(Aar >= 2013)
  timeSeriesRodents = timeSeriesRodents %>% mutate(NumLines = 1) 
  timeSeriesRodents = timeSeriesRodents %>% group_by(Aar) %>% summarise(SeeRodPercent = (sum(SettSmagnager)/sum(NumLines))*100)
  timeSeriesRodents = timeSeriesRodents %>% mutate(Year = Aar)
  timeSeriesRodents$Year = as.character.Date(timeSeriesRodents$Year)
  
```  
  
```{r CREATE AND EXPORT PLOTS NINA EVENSTAD, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}
  
if(all(is.na(unique(timeSeriesDF$Estimat))) == TRUE){
  
  timeSeriesTot$Estimat = 0
  timeSeriesAd$Estimat = 0
  timeSeriesChick$Estimat = 0
  #timeSeriesRodents$Estimat = 0
  
  tsTotPlot = ggplot(data = timeSeriesTot, aes(x=Year, y=Estimat, group = Faktor)) +
    labs(title = ReportLevelOut, subtitle = bquote("a) Total tetthet - Antall fugl/"*km^2)) +
    xlab("År") +
    ylab(bquote(phantom(0)["Tetthet (95% KI)"])) + theme(text = element_text(size = 8), axis.title.y = element_text(size = 12)) + scale_y_continuous(breaks = integer_breaks(), limits = c(0, 40))
  
  tsAdPlot = ggplot(data = timeSeriesAd, aes(x=Year, y=Estimat, group = Faktor)) +
    labs(title = ReportLevelOut, subtitle = bquote("a) Voksen tetthet - Antall fugl/"*km^2)) +
    xlab("År") +
    ylab(bquote(phantom(0)["Tetthet (95% KI)"])) + theme(text = element_text(size = 8), axis.title.y = element_text(size = 12)) + scale_y_continuous(breaks = integer_breaks(), limits = c(0, 10))
  
  tsChickPlot = ggplot(data = timeSeriesChick, aes(x=Year, y=Estimat, group = Faktor)) +
    labs(title = ReportLevelOut, subtitle = bquote("a) Kylling tetthet - Antall fugl/"*km^2)) +
    xlab("År") +
    ylab(bquote(phantom(0)["Tetthet (95% KI)"])) + theme(text = element_text(size = 8), axis.title.y = element_text(size = 12)) + scale_y_continuous(breaks = integer_breaks(), limits = c(0, 10))
  
  tsRodentsPlot = ggplot(data = timeSeriesRodents, aes(x = Year, y = SeeRodPercent, group = 1)) + geom_point() +
    geom_line(color = "black", size = 1, alpha = 1, linetype = 1) +
    labs(title = ReportLevelOut, subtitle = bquote("d) Smågnager observasjoner")) +
    xlab("År") +
    ylab("Andel smågnager obs. (%)") +
    theme(text = element_text(size = 8)) + scale_y_continuous(breaks = integer_breaks(), limits = c(0, ceiling(max(timeSeriesRodents$SeeRodPercent, na.rm = TRUE))))
    #ggplot(data = timeSeriesRodents, aes(x=Year, y=Estimat, group = 1)) +
    #labs(title = ReportLevelOut, subtitle = "Smågnager observasjoner") +
    #xlab("År") +
    #ylab("Ander smågnager obs. (%)") + theme(text = element_text(size = 8), axis.title.y = element_text(size = 8)) + scale_y_continuous(breaks = integer_breaks(), limits = c(0, 40))

} else{

  # Total density plot
  tsTotPlot = ggplot(data = timeSeriesTot, aes(x=Year, y=Estimat, group = Faktor)) + geom_point() +
    geom_line(color="black", size=1, alpha=1, linetype=1) +
    labs(title = ReportLevelOut, subtitle = bquote("a) Total tetthet - Antall fugl/"*km^2)) +
    xlab("År") +
    ylab(bquote(phantom(0)["Tetthet (95% KI)"])) +
    geom_ribbon(aes(ymin = `Nedre CL`, ymax = `Øvre CL`), alpha = 0.4, fill = "steelblue") + theme(text = element_text(size = 8), axis.title.y = element_text(size = 12)) + scale_y_continuous(breaks = integer_breaks(), limits = c(0, ceiling(max(timeSeriesTot$`Øvre CL`, na.rm = TRUE))))

 # Adult density plot
 tsAdPlot = ggplot(data = timeSeriesAd, aes(x = Year, y = Estimat, group = Faktor)) + geom_point() +
   geom_line(color = "black", size = 1, alpha = 1, linetype = 1) +
   labs(title = ReportLevelOut, subtitle = bquote("b) Voksen tetthet - Antall fugl/"*km^2)) +
   xlab("År") +
   ylab(bquote(phantom(0)["Tetthet (95% KI)"])) +
   geom_ribbon(aes(ymin = `Nedre CL`, ymax = `Øvre CL`), alpha = 0.4, fill = "steelblue") +
   theme(text = element_text(size = 8), axis.title.y = element_text(size = 12)) + scale_y_continuous(breaks = integer_breaks(), limits = c(0, ceiling(max(timeSeriesAd$`Øvre CL`, na.rm = TRUE))))

 # Chick density plot
 tsChickPlot = ggplot(data = timeSeriesChick, aes(x = Year, y = Estimat, group = Faktor)) + geom_point() +
     geom_line(color = "black", size = 1, alpha = 1, linetype = 1) +
     labs(title = ReportLevelOut, subtitle = bquote("c) Kylling tetthet - Antall fugl/"*km^2)) +
     xlab("År") +
     ylab(bquote(phantom(0)["Tetthet (95% KI)"])) +
     geom_ribbon(aes(ymin = `Nedre CL`, ymax = `Øvre CL`), alpha = 0.4, fill = "steelblue") +
     theme(text = element_text(size = 8), axis.title.y = element_text(size = 12)) + scale_y_continuous(breaks = integer_breaks(), limits = c(0, ceiling(max(timeSeriesChick$`Øvre CL`, na.rm = TRUE))))

 # Proportion of rodents observered plot
  tsRodentsPlot = ggplot(data = timeSeriesRodents, aes(x = Year, y = SeeRodPercent, group = 1)) + geom_point() +
    geom_line(color = "black", size = 1, alpha = 1, linetype = 1) +
    labs(title = ReportLevelOut, subtitle = bquote("d) Smågnager observasjoner")) +
    xlab("År") +
    ylab("Andel smågnager obs. (%)") +
    theme(text = element_text(size = 8)) + scale_y_continuous(breaks = integer_breaks(), limits = c(0, ceiling(max(timeSeriesRodents$SeeRodPercent, na.rm = TRUE))))

}

 # Collate the four figures into one
 ggarrange(tsTotPlot, tsAdPlot, tsChickPlot, tsRodentsPlot)

  # Save the plot with naming including area and last year of monitoring
 if(ReportLevelOut == "Bjoreidalen - syd/nord"){
   ReportLevelOut = "Bjoreidalen - SydNord"
 }
  ggsave(filename = paste("C:/Users/markus.israelsen/OneDrive - NINA/GitHub/HonsefuglReport/Honsefugl-Report/Figures/", ReportLevelOut, "-", max(years), ".jpg", sep = ""), width = 7, height = 7, units = "in")
  
```
**Figur 1**. Figuren viser a) estimert total tetthet (antall observasjoner / km^2^) for lirype, b) estimert voksen tetthet (antall voksne fugler observert / km^2^) for lirype, c) estimert kylling tetthet (antall kyllinger observert / km^2^) for lirype og til slutt d) andelen (%) av smågnagere observert for området (antall smågnagere observert / antall aktive linjer). Det blå feltet rundt trendlinjen i figur a), b) og c) representerer 95% konfidensintervallet til estimatet. 

```{r, echo=FALSE, eval = TRUE}

Fig1(klasser=10)  

```
**Figur 2**. Figuren til venstre viser oppdagbarheten fra takseringslinja og utover (totalt for området). Effektiv stripebredde (ESW) er den avstanden fra linja der det er gjort like mange observasjoner utenfor som anslått ikke funnet innenfor. Med trunkering menes her at de `r trunk` observasjoner som er lengst bort fra linja er fjernet (for å jevne ut oppdagbarhetskurven) - hvilken avstand dette gjelder er notert over. Figuren til høyre er en gjengivelse av oppdagbarhetskurven, med usikkerhetsmål angitt.
